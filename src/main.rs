//! This example shows how to create a custom render pass that runs after the main pass
//! and reads the texture generated by the main pass.
//!
//! The example shader is a very simple implementation of chromatic aberration.
//! To adapt this example for 2D, replace all instances of 3D structures (such as `Core3D`, etc.) with their corresponding 2D counterparts.
//!
//! This is a fairly low level example and assumes some familiarity with rendering concepts and wgpu.

use std::{f32::consts::PI, ops::Deref};

use bevy::{
    color::palettes::css::{self, ORANGE_RED, WHITE},
    picking::backend::ray::RayMap,
    prelude::*,
    render::{RenderPlugin, camera::RenderTarget, mesh::Indices, render_resource::*},
};
use bevy_panorbit_camera::{PanOrbitCamera, PanOrbitCameraPlugin};
use bevy_rapier3d::prelude::*;
use learn_shader::export_image::{
    ImageExport, ImageExportPlugin, ImageExportSettings, ImageExportSource,
};
use learn_shader::post_processing::PostProcessPlugin;

fn main() {
    let export_plugin = ImageExportPlugin::default();
    let export_threads = export_plugin.threads.clone();

    App::new()
        .add_plugins(DefaultPlugins.set(RenderPlugin {
            synchronous_pipeline_compilation: true,
            ..default()
        }))
        .add_plugins(RapierPhysicsPlugin::<NoUserData>::default())
        .add_plugins(RapierDebugRenderPlugin::default())
        .add_plugins(PanOrbitCameraPlugin)
        .add_plugins(export_plugin)
        .add_systems(Startup, setup)
        .add_systems(Update, rotate)
        .add_systems(Update, bouncing_raycast)
        .add_systems(Update, screen_shot)
        .run();
    export_threads.finish();
}

// Bounces a ray off of surfaces `MAX_BOUNCES` times.
fn bounce_ray(mut ray: Ray3d, ray_cast: &mut MeshRayCast, gizmos: &mut Gizmos, color: Color) {
    let mut intersections = Vec::with_capacity(MAX_BOUNCES + 1);
    intersections.push((ray.origin, Color::srgb(30.0, 0.0, 0.0)));

    for i in 0..MAX_BOUNCES {
        // Cast the ray and get the first hit
        let Some((_, hit)) = ray_cast.cast_ray(ray, &RayCastSettings::default()).first() else {
            break;
        };

        // Draw the point of intersection and add it to the list
        let brightness = 1.0 + 10.0 * (1.0 - i as f32 / MAX_BOUNCES as f32);
        intersections.push((hit.point, Color::BLACK.mix(&color, brightness)));
        gizmos.sphere(hit.point, 0.005, Color::BLACK.mix(&color, brightness * 2.0));

        // Reflect the ray off of the surface
        ray.direction = Dir3::new(ray.direction.reflect(hit.normal)).unwrap();
        ray.origin = hit.point + ray.direction * 1e-6;
    }
    gizmos.linestrip_gradient(intersections);
}

const MAX_BOUNCES: usize = 64;
const LASER_SPEED: f32 = 0.03;

fn bouncing_raycast(
    mut ray_cast: MeshRayCast,
    mut gizmos: Gizmos,
    time: Res<Time>,
    // The ray map stores rays cast by the cursor
    ray_map: Res<RayMap>,
    material_handles: Query<(&MeshMaterial3d<StandardMaterial>, &Mesh3d)>,
    materials: Res<Assets<StandardMaterial>>,
    imgs: Res<Assets<Image>>,
    meshes: Res<Assets<Mesh>>,
    // Option<Read<Mesh2d>>,
    // Option<Read<Mesh3d>>,
    // Option<Read<SimplifiedMesh>>,
) {
    // Cast an automatically moving ray and bounce it off of surfaces
    let t = ops::cos((time.elapsed_secs() - 4.0).max(0.0) * LASER_SPEED) * PI;
    let ray_pos = Vec3::new(ops::sin(t), ops::cos(3.0 * t) * 0.5, ops::cos(t)) * 0.5;
    let ray_dir = Dir3::new(-ray_pos).unwrap();
    let ray = Ray3d::new(ray_pos, ray_dir);
    gizmos.sphere(ray_pos, 0.1, Color::WHITE);
    bounce_ray(ray, &mut ray_cast, &mut gizmos, Color::from(css::RED));

    // Cast a ray from the cursor and bounce it off of surfaces
    let mut count = 0;
    for (_, ray) in ray_map.iter() {
        bounce_ray(*ray, &mut ray_cast, &mut gizmos, Color::from(css::GREEN));
        println!("count {}", count);
        count += 1;
        if let Some((entity, hit)) = ray_cast.cast_ray(*ray, &RayCastSettings::default()).first() {
            println!(
                "entity id {} tri idx {}",
                entity.index(),
                hit.triangle_index.unwrap_or(0)
            );
            if let Ok((m, mesh3d)) = material_handles.get(*entity) {
                if let Some(mm) = materials.get(m) {
                    if let Some(mesh) = meshes.get(mesh3d) {
                        for (ai, av) in mesh.attributes() {
                            println!("got mesh {:?} {:?}", ai, av.len());
                        }

                        println!("topo {:?}", mesh.primitive_topology());
                        let indices = mesh.indices().unwrap();
                        // println!("idxes {}",mesh.indices().unwrap().len());
                        match indices {
                            Indices::U16(vec) => {
                                let l = vec.as_slice().chunks_exact(3).len();
                                println!("indexes len {}", l);
                            }
                            Indices::U32(vec) => {
                                let l = vec.as_slice().chunks_exact(3).len();
                                println!("indexes len2 {}", l);
                            }
                        };
                    }
                    println!(
                        "mm {} {} {:?}",
                        mm.metallic, mm.perceptual_roughness, mm.base_color
                    );
                    if let Some(img) = &mm.base_color_texture {
                        // println!("uv {}", mm.base_color_channel);
                        let im = imgs.get(img);
                        println!("d {} len {}", im.unwrap().data[0], im.unwrap().data.len());
                        let tri = hit.triangle.unwrap();
                        let tri_idx = hit.triangle_index.unwrap();
                        println!("tri {} {} {} {}", tri_idx, tri[0], tri[1], tri[2]);
                        // im.unwrap().get_color_at(x, y)
                    }
                }
                // println!("{}", m.0)
            }
        }
    }
    println!("materials: {}\n", material_handles.iter().len());
}

#[derive(Component)]
struct Target;

/// Set up a simple 3D scene
fn setup(
    mut commands: Commands,
    mut meshes: ResMut<Assets<Mesh>>,
    mut materials: ResMut<Assets<StandardMaterial>>,
    asset_server: Res<AssetServer>,
    mut images: ResMut<Assets<Image>>,
    mut export_sources: ResMut<Assets<ImageExportSource>>,
) {
    // cube
    commands.spawn((
        Mesh3d(meshes.add(Cuboid::default())),
        MeshMaterial3d(materials.add(Color::srgb(0.8, 0.7, 0.6))),
        Transform::from_xyz(2.6, 0.5, 0.0),
        Rotates,
    ));
    // light
    commands.spawn(DirectionalLight {
        illuminance: 1_000.,
        ..default()
    });
    commands.spawn((
        SceneRoot(
            asset_server.load(
                GltfAssetLabel::Scene(0).from_asset("models/full_gameready_city_buildings.glb"),
            ),
        ),
        Target,
    ));
    commands
        .spawn(Collider::cuboid(60.0, 1.0, 60.0))
        .insert(Transform::from_xyz(0.0, -1.0, 0.0));
    // ambient light
    commands.insert_resource(AmbientLight {
        color: WHITE.into(),
        brightness: 1000.0,
    });

    let output_texture_handle0 = {
        let size = Extent3d {
            width: 3840,
            height: 2160,
            ..default()
        };
        let mut export_texture = Image {
            texture_descriptor: TextureDescriptor {
                label: None,
                size,
                dimension: TextureDimension::D2,
                format: TextureFormat::Rgba8UnormSrgb,
                mip_level_count: 1,
                sample_count: 1,
                usage: TextureUsages::COPY_DST
                    | TextureUsages::COPY_SRC
                    | TextureUsages::RENDER_ATTACHMENT,
                view_formats: &[],
            },
            ..default()
        };
        export_texture.resize(size);

        images.add(export_texture)
    };
    let output_texture_handle1 = {
        let size = Extent3d {
            width: 3840,
            height: 2160,
            ..default()
        };
        let mut export_texture = Image {
            texture_descriptor: TextureDescriptor {
                label: None,
                size,
                dimension: TextureDimension::D2,
                format: TextureFormat::Rgba8UnormSrgb,
                mip_level_count: 1,
                sample_count: 1,
                usage: TextureUsages::COPY_DST
                    | TextureUsages::COPY_SRC
                    | TextureUsages::RENDER_ATTACHMENT,
                view_formats: &[],
            },
            ..default()
        };
        export_texture.resize(size);

        images.add(export_texture)
    };
    commands
        .spawn((
            Transform::from_translation(Vec3::new(0.0, 1.5, 5.0)),
            PanOrbitCamera::default(),
        ))
        .with_child((
            Transform::from_translation(Vec3::new(1.0, 0.0, 0.0)),
            Camera3d::default(),
            Camera {
                target: RenderTarget::Image(output_texture_handle0.clone().into()),
                ..default()
            },
        ))
        .with_child((
            Transform::from_translation(Vec3::new(2.0, 0.0, 0.0)),
            Camera3d::default(),
            Camera {
                target: RenderTarget::Image(output_texture_handle1.clone().into()),
                ..default()
            },
        ));
    // commands.spawn(ImageExport(export_sources.add(output_texture_handle)));
    // Spawn the ImageExport component to initiate the export of the output texture.
    commands.spawn((
        ImageExport(export_sources.add(output_texture_handle0)),
        ImageExportSettings {
            // Frames will be saved to "./out/[#####].png".
            output_dir: "out0".into(),
            // Choose "exr" for HDR renders.
            extension: "jpeg".into(),
            enabled: true,
            ..default()
        },
    ));
    commands.spawn((
        ImageExport(export_sources.add(output_texture_handle1)),
        ImageExportSettings {
            // Frames will be saved to "./out/[#####].png".
            output_dir: "out1".into(),
            // Choose "exr" for HDR renders.
            extension: "png".into(),
            enabled: true,
            ..default()
        },
    ));
}

#[derive(Component)]
struct Rotates;

/// Rotates any entity around the x and y axis
fn rotate(time: Res<Time>, mut query: Query<&mut Transform, With<Rotates>>) {
    for mut transform in &mut query {
        transform.rotate_x(0.55 * time.delta_secs());
        transform.rotate_z(0.15 * time.delta_secs());
    }
}

fn screen_shot(mut query: Query<&mut ImageExportSettings>, keyboard: Res<ButtonInput<KeyCode>>) {
    for mut setting in &mut query {
        setting.enabled = false;
    }
    if keyboard.just_pressed(KeyCode::Space) {
        println!("screenshot!");
        for mut setting in &mut query {
            setting.enabled = true;
        }
    }
}
