//! This example shows how to create a custom render pass that runs after the main pass
//! and reads the texture generated by the main pass.
//!
//! The example shader is a very simple implementation of chromatic aberration.
//! To adapt this example for 2D, replace all instances of 3D structures (such as `Core3D`, etc.) with their corresponding 2D counterparts.
//!
//! This is a fairly low level example and assumes some familiarity with rendering concepts and wgpu.

use rayon::prelude::*;
use std::{
    f32::{MAX, consts::PI},
    ops::Deref,
    time::Instant,
};

use bevy::{
    color::palettes::css::{self, ORANGE_RED, WHITE},
    ecs::system::{SystemParam, lifetimeless::Read},
    math::{FloatOrd, bounding::Aabb3d},
    picking::{
        backend::ray::RayMap,
        mesh_picking::ray_cast::{
            Backfaces, RayMeshHit, SimplifiedMesh, ray_aabb_intersection_3d, ray_mesh_intersection,
        },
    },
    prelude::*,
    render::{
        RenderPlugin, camera::RenderTarget, mesh::Indices, primitives::Aabb, render_resource::*,
    },
};
use bevy_panorbit_camera::{PanOrbitCamera, PanOrbitCameraPlugin};
use bevy_rapier3d::prelude::*;
use learn_shader::export_image::{
    ImageExport, ImageExportPlugin, ImageExportSettings, ImageExportSource,
};
use learn_shader::post_processing::PostProcessPlugin;

fn main() {
    let export_plugin = ImageExportPlugin::default();
    let export_threads = export_plugin.threads.clone();

    App::new()
        .add_plugins(DefaultPlugins.set(RenderPlugin {
            synchronous_pipeline_compilation: true,
            ..default()
        }))
        .add_plugins(RapierPhysicsPlugin::<NoUserData>::default())
        .add_plugins(RapierDebugRenderPlugin::default())
        .add_plugins(PanOrbitCameraPlugin)
        .add_plugins(export_plugin)
        .add_systems(Startup, setup)
        .add_systems(Update, rotate)
        .add_systems(Update, bouncing_raycast)
        .add_systems(Update, screen_shot)
        .run();
    export_threads.finish();
}

// Bounces a ray off of surfaces `MAX_BOUNCES` times.
fn bounce_ray(mut ray: Ray3d, ray_cast: &mut MeshRayCast2, gizmos: &mut Gizmos, color: Color) {
    let mut intersections = Vec::with_capacity(MAX_BOUNCES + 1);
    intersections.push((ray.origin, Color::srgb(30.0, 0.0, 0.0)));

    for i in 0..MAX_BOUNCES {
        // Cast the ray and get the first hit
        let Some((_, hit)) =
            ray_cast.cast_ray_once(ray, &MeshRayCastSettings::default(), MAX_DISTANCE)
        else {
            break;
        };

        // Draw the point of intersection and add it to the list
        let brightness = 1.0 + 10.0 * (1.0 - i as f32 / MAX_BOUNCES as f32);
        intersections.push((hit.point, Color::BLACK.mix(&color, brightness)));
        gizmos.sphere(hit.point, 0.005, Color::BLACK.mix(&color, brightness * 2.0));

        // Reflect the ray off of the surface
        ray.direction = Dir3::new(ray.direction.reflect(hit.normal)).unwrap();
        ray.origin = hit.point + ray.direction * 1e-6;
    }
    gizmos.linestrip_gradient(intersections);
}
fn bounce_ray_once_ori(ray: Ray3d, ray_cast: &mut MeshRayCast) -> Option<Vec3> {
    if let Some((_, hit)) = ray_cast
        .cast_ray(ray, &MeshRayCastSettings::default().always_early_exit())
        .first()
    {
        Some(hit.point)
    } else {
        None
    }
}

// Bounces a ray off of surfaces `MAX_BOUNCES` times.
fn bounce_ray_once(ray: Ray3d, ray_cast: &MeshRayCast2) -> Option<Vec3> {
    if let Some((_, hit)) = ray_cast.cast_ray_once(
        ray,
        &MeshRayCastSettings::default().always_early_exit(),
        MAX_DISTANCE,
    ) {
        Some(hit.point)
    } else {
        None
    }
}

const MAX_BOUNCES: usize = 1;
const LASER_SPEED: f32 = 0.03;
const MAX_DISTANCE: f32 = 10.0;
fn ouster_original(ray: Ray3d, ray_cast: &mut MeshRayCast, gizmos: &mut Gizmos) {
    const HSCAN: usize = 40;
    const HFOV: f32 = 60.0_f32.to_radians();
    const HSTEP: f32 = HFOV / (HSCAN - 1) as f32;
    const HSTART: f32 = -HFOV / 2.0;

    const VSCAN: usize = 30;
    const VFOV: f32 = 30.0_f32.to_radians();
    const VSTEP: f32 = VFOV / (VSCAN - 1) as f32;
    const VSTART: f32 = -VFOV / 2.0;

    for v in 0..VSCAN {
        let v_angle = VSTART + v as f32 * VSTEP;
        let points: Vec<_> = (0..HSCAN)
            .into_iter()
            .filter_map(|h| {
                let h_angle = HSTART + h as f32 * HSTEP;

                // 建立一個方向是 h_angle 與 v_angle 的單位向量
                let direction =
                    Quat::from_rotation_y(h_angle) * Quat::from_rotation_x(v_angle) * ray.direction;

                let new_ray = Ray3d {
                    origin: ray.origin,
                    direction: direction,
                };
                bounce_ray_once_ori(new_ray, ray_cast)
            })
            .collect();
        points.iter().for_each(|&p| {
            gizmos.sphere(p, 0.005, css::RED);
        });
    }
}

fn ouster(ray: Ray3d, ray_cast: &MeshRayCast2, gizmos: &mut Gizmos) {
    const HSCAN: usize = 40;
    const HFOV: f32 = 60.0_f32.to_radians();
    const HSTEP: f32 = HFOV / (HSCAN - 1) as f32;
    const HSTART: f32 = -HFOV / 2.0;

    const VSCAN: usize = 30;
    const VFOV: f32 = 30.0_f32.to_radians();
    const VSTEP: f32 = VFOV / (VSCAN - 1) as f32;
    const VSTART: f32 = -VFOV / 2.0;

    for v in 0..VSCAN {
        let v_angle = VSTART + v as f32 * VSTEP;
        let points: Vec<_> = (0..HSCAN)
            .par_bridge()
            .filter_map(|h| {
                let h_angle = HSTART + h as f32 * HSTEP;

                // 建立一個方向是 h_angle 與 v_angle 的單位向量
                let direction =
                    Quat::from_rotation_y(h_angle) * Quat::from_rotation_x(v_angle) * ray.direction;

                let new_ray = Ray3d {
                    origin: ray.origin,
                    direction: direction,
                };
                bounce_ray_once(new_ray, ray_cast)
            })
            .collect();
        points.iter().for_each(|&p| {
            gizmos.sphere(p, 0.005, css::RED);
        });
    }
}

pub fn ray_intersection_over_mesh(
    mesh: &Mesh,
    transform: &GlobalTransform,
    ray: Ray3d,
    culling: Backfaces,
) -> Option<RayMeshHit> {
    if mesh.primitive_topology() != PrimitiveTopology::TriangleList {
        return None; // ray_mesh_intersection assumes vertices are laid out in a triangle list
    }
    // Vertex positions are required
    let positions = mesh.attribute(Mesh::ATTRIBUTE_POSITION)?.as_float3()?;

    // Normals are optional
    let normals = mesh
        .attribute(Mesh::ATTRIBUTE_NORMAL)
        .and_then(|normal_values| normal_values.as_float3());

    let transform = &transform.compute_matrix();

    match mesh.indices() {
        Some(Indices::U16(indices)) => {
            ray_mesh_intersection(ray, transform, positions, normals, Some(indices), culling)
        }
        Some(Indices::U32(indices)) => {
            ray_mesh_intersection(ray, transform, positions, normals, Some(indices), culling)
        }
        None => ray_mesh_intersection::<usize>(ray, transform, positions, normals, None, culling),
    }
}

type MeshFilter = Or<(With<Mesh3d>, With<Mesh2d>, With<SimplifiedMesh>)>;

#[derive(SystemParam)]
pub struct MeshRayCast2<'w, 's> {
    #[doc(hidden)]
    pub meshes: Res<'w, Assets<Mesh>>,
    #[doc(hidden)]
    pub culling_query: Query<
        'w,
        's,
        (
            Read<InheritedVisibility>,
            Read<ViewVisibility>,
            Read<Aabb>,
            Read<GlobalTransform>,
            Entity,
        ),
        MeshFilter,
    >,
    #[doc(hidden)]
    pub mesh_query: Query<
        'w,
        's,
        (
            Option<Read<Mesh2d>>,
            Option<Read<Mesh3d>>,
            Option<Read<SimplifiedMesh>>,
            Has<RayCastBackfaces>,
            Read<GlobalTransform>,
        ),
        MeshFilter,
    >,
}

impl<'w, 's> MeshRayCast2<'w, 's> {
    /// Casts the `ray` into the world and returns a sorted list of intersections, nearest first.
    pub fn cast_ray_once(
        &self,
        ray: Ray3d,
        settings: &MeshRayCastSettings,
        max_distance: f32,
    ) -> Option<(Entity, RayMeshHit)> {
        let ray_cull = info_span!("ray culling");
        let ray_cull_guard = ray_cull.enter();

        let mut hits = Vec::new();

        let timer0 = Instant::now();

        // Check all entities to see if the ray intersects the AABB. Use this to build a short list
        // of entities that are in the path of the ray.
        let (aabb_hits_tx, aabb_hits_rx) = crossbeam_channel::unbounded::<(FloatOrd, Entity)>();
        let visibility_setting = settings.visibility;
        self.culling_query.par_iter().for_each(
            |(inherited_visibility, view_visibility, aabb, transform, entity)| {
                let should_ray_cast = match visibility_setting {
                    RayCastVisibility::Any => true,
                    RayCastVisibility::Visible => inherited_visibility.get(),
                    RayCastVisibility::VisibleInView => view_visibility.get(),
                };
                if should_ray_cast {
                    if let Some(distance) = ray_aabb_intersection_3d(
                        ray,
                        &Aabb3d::new(aabb.center, aabb.half_extents),
                        &transform.compute_matrix(),
                    ) {
                        aabb_hits_tx.send((FloatOrd(distance), entity)).ok();
                    }
                }
            },
        );
        let mut culled_list: Vec<_> = aabb_hits_rx.try_iter().collect();
        // println!("cull {}", culled_list.len());
        let elapsed_time0 = timer0.elapsed();

        // Sort by the distance along the ray.
        culled_list.sort_by_key(|(aabb_near, _)| *aabb_near);

        drop(ray_cull_guard);

        // Perform ray casts against the culled entities.
        let mut nearest_blocking_hit = FloatOrd(max_distance);
        let ray_cast_guard = debug_span!("ray_cast");

        let filtered_list = culled_list
            .iter()
            .filter(|(_, entity)| (settings.filter)(*entity));
        let timer1 = Instant::now();
        for (aabb_near, entity) in filtered_list {
            // .for_each(|(aabb_near, entity)| {
            // Get the mesh components and transform.
            let Ok((mesh2d, mesh3d, simplified_mesh, has_backfaces, transform)) =
                self.mesh_query.get(*entity)
            else {
                continue;
                // return;
            };

            // Get the underlying mesh handle. One of these will always be `Some` because of the query filters.
            let Some(mesh_handle) = simplified_mesh
                .map(|m| &m.0)
                .or(mesh3d.map(|m| &m.0).or(mesh2d.map(|m| &m.0)))
            else {
                continue;
                // return;
            };

            // Is it even possible the mesh could be closer than the current best?
            if *aabb_near > nearest_blocking_hit {
                continue;
                // return;
            }

            // Does the mesh handle resolve?
            let Some(mesh) = self.meshes.get(mesh_handle) else {
                continue;
                // return;
            };

            // Backfaces of 2d meshes are never culled, unlike 3d meshes.
            let backfaces = match (has_backfaces, mesh2d.is_some()) {
                (false, false) => Backfaces::Cull,
                _ => Backfaces::Include,
            };

            // Perform the actual ray cast.
            let _ray_cast_guard = ray_cast_guard.enter();
            // let transform = transform.compute_matrix();
            let intersection = ray_intersection_over_mesh(mesh, &transform, ray, backfaces);

            if let Some(intersection) = intersection {
                let distance = FloatOrd(intersection.distance);
                if (settings.early_exit_test)(*entity) && distance < nearest_blocking_hit {
                    // The reason we don't just return here is because right now we are
                    // going through the AABBs in order, but that doesn't mean that an
                    // AABB that starts further away can't end up with a closer hit than
                    // an AABB that starts closer. We need to keep checking AABBs that
                    // could possibly contain a nearer hit.
                    nearest_blocking_hit = distance.min(nearest_blocking_hit);
                    hits.push((distance, (*entity, intersection)));
                }
                // return Some((*entity, intersection));
                // hits.push((distance, (*entity, intersection)));
            };
        }
        // println!("hits {}", hits.len());
        let elapsed_time1 = timer1.elapsed();
        // println!("time {} {}", elapsed_time0.as_micros(), elapsed_time1.as_micros());
        hits.retain(|(dist, _)| *dist <= nearest_blocking_hit);
        hits.sort_by_key(|(k, _)| *k);
        if let Some((_, (e, i))) = hits.first() {
            Some((*e, i.to_owned()))
        } else {
            None
        }
        // hits.iter().map(|(_, (e, i))| (*e, i.to_owned())).collect()
    }
}

fn bouncing_raycast(
    mut ray_cast: MeshRayCast2,
    mut gizmos: Gizmos,
    time: Res<Time>,
    // The ray map stores rays cast by the cursor
    ray_map: Res<RayMap>,
    material_handles: Query<(&MeshMaterial3d<StandardMaterial>, &Mesh3d)>,
    materials: Res<Assets<StandardMaterial>>,
    imgs: Res<Assets<Image>>,
    meshes: Res<Assets<Mesh>>,
    // Option<Read<Mesh2d>>,
    // Option<Read<Mesh3d>>,
    // Option<Read<SimplifiedMesh>>,
) {
    // Cast an automatically moving ray and bounce it off of surfaces
    let t = ops::cos((time.elapsed_secs() - 4.0).max(0.0) * LASER_SPEED) * PI;
    let ray_pos = Vec3::new(ops::sin(t), ops::cos(3.0 * t) * 0.5, ops::cos(t)) * 0.5;
    let ray_dir = Dir3::new(-ray_pos).unwrap();
    let ray = Ray3d::new(ray_pos, ray_dir);
    gizmos.sphere(ray_pos, 0.1, Color::WHITE);
    // bounce_ray(ray, &mut ray_cast, &mut gizmos, Color::from(css::RED));

    // Cast a ray from the cursor and bounce it off of surfaces
    let mut count = 0;
    for (_, ray) in ray_map.iter() {
        let now = Instant::now();

        ouster(*ray, &ray_cast, &mut gizmos);
        let elapsed_time = now.elapsed();
        println!("Running took {} micro seconds.", elapsed_time.as_micros());
        // bounce_ray(*ray, &mut ray_cast, &mut gizmos, Color::from(css::GREEN));
        break;
        println!("count {}", count);
        count += 1;
        // if let Some((entity, hit)) =
        //     ray_cast.cast_ray_once(*ray, &RayCastSettings::default(), MAX_DISTANCE)
        // {
        //     println!(
        //         "entity id {} tri idx {}",
        //         entity.index(),
        //         hit.triangle_index.unwrap_or(0)
        //     );
        //     if let Ok((m, mesh3d)) = material_handles.get(entity) {
        //         if let Some(mm) = materials.get(m) {
        //             println!(
        //                 "mm {} {} {:?}",
        //                 mm.metallic, mm.perceptual_roughness, mm.base_color
        //             );
        //             if let Some(img) = &mm.base_color_texture {
        //                 // println!("uv {}", mm.base_color_channel);
        //                 let im = imgs.get(img);
        //                 println!("d {} len {}", im.unwrap().data[0], im.unwrap().data.len());
        //                 hit.barycentric_coords;
        //                 let tri = hit.triangle.unwrap();
        //                 let tri_idx = hit.triangle_index.unwrap();
        //                 println!("tri {} {} {} {}", tri_idx, tri[0], tri[1], tri[2]);
        //                 // im.unwrap().get_color_at(x, y)
        //                 if let Some(mesh) = meshes.get(mesh3d) {
        //                     for (ai, av) in mesh.attributes() {
        //                         println!("got mesh {:?} {:?}", ai, av.len());
        //                     }

        //                     println!("topo {:?}", mesh.primitive_topology());
        //                     let indices = mesh.indices().expect("aaaaa");
        //                     // println!("idxes {}",mesh.indices().unwrap().len());
        //                     let vertex_idxs = match indices {
        //                         Indices::U16(vec) => {
        //                             let ids = vec.as_slice().chunks_exact(3).nth(tri_idx).unwrap();
        //                             [ids[0] as usize, ids[1] as usize, ids[2] as usize]
        //                         }
        //                         Indices::U32(vec) => {
        //                             let mut v = vec.as_slice().chunks_exact(3);
        //                             println!("vv {}", v.len());
        //                             if tri_idx >= v.len() {
        //                                 continue;
        //                             }
        //                             let ids = v.nth(tri_idx).expect("abc");
        //                             [ids[0] as usize, ids[1] as usize, ids[2] as usize]
        //                         }
        //                     };
        //                     if let Some(bevy::render::mesh::VertexAttributeValues::Float32x2(uvs)) =
        //                         mesh.attribute(Mesh::ATTRIBUTE_UV_0)
        //                     {
        //                         println!("items len {}", uvs.len());
        //                         for i in vertex_idxs {
        //                             println!("uvs {:?}", uvs[i]);
        //                         }
        //                         let uv0 = Vec2::from_array(uvs[vertex_idxs[0]]);
        //                         let uv1 = Vec2::from_array(uvs[vertex_idxs[1]]);
        //                         let uv2 = Vec2::from_array(uvs[vertex_idxs[2]]);

        //                         let uv = uv0 * hit.barycentric_coords.x
        //                             + uv1 * hit.barycentric_coords.y
        //                             + uv2 * hit.barycentric_coords.z;
        //                         println!("uv {}", uv);
        //                     }
        //                 }
        //             }
        //         }
        //         // println!("{}", m.0)
        //     }
        // }
    }
    println!("materials: {}\n", material_handles.iter().len());
}

#[derive(Component)]
struct Target;

/// Set up a simple 3D scene
fn setup(
    mut commands: Commands,
    mut meshes: ResMut<Assets<Mesh>>,
    mut materials: ResMut<Assets<StandardMaterial>>,
    asset_server: Res<AssetServer>,
    mut images: ResMut<Assets<Image>>,
    mut export_sources: ResMut<Assets<ImageExportSource>>,
) {
    // cube
    commands.spawn((
        Mesh3d(meshes.add(Cuboid::default())),
        MeshMaterial3d(materials.add(Color::srgb(0.8, 0.7, 0.6))),
        Transform::from_xyz(2.6, 0.5, 0.0),
        Rotates,
    ));
    // light
    commands.spawn(DirectionalLight {
        illuminance: 1_000.,
        ..default()
    });
    commands.spawn((
        SceneRoot(
            asset_server.load(
                GltfAssetLabel::Scene(0).from_asset("models/full_gameready_city_buildings.glb"),
            ),
        ),
        Target,
    ));
    commands
        .spawn(Collider::cuboid(60.0, 1.0, 60.0))
        .insert(Transform::from_xyz(0.0, -1.0, 0.0));
    // ambient light
    commands.insert_resource(AmbientLight {
        color: WHITE.into(),
        brightness: 1000.0,
        affects_lightmapped_meshes: true,
    });

    let output_texture_handle0 = {
        let size = Extent3d {
            width: 100,
            height: 100,
            ..default()
        };
        let mut export_texture = Image {
            texture_descriptor: TextureDescriptor {
                label: None,
                size,
                dimension: TextureDimension::D2,
                format: TextureFormat::Rgba8UnormSrgb,
                mip_level_count: 1,
                sample_count: 1,
                usage: TextureUsages::COPY_DST
                    | TextureUsages::COPY_SRC
                    | TextureUsages::RENDER_ATTACHMENT,
                view_formats: &[],
            },
            ..default()
        };
        export_texture.resize(size);

        images.add(export_texture)
    };
    let output_texture_handle1 = {
        let size = Extent3d {
            width: 100,
            height: 100,
            ..default()
        };
        let mut export_texture = Image {
            texture_descriptor: TextureDescriptor {
                label: None,
                size,
                dimension: TextureDimension::D2,
                format: TextureFormat::Rgba8UnormSrgb,
                mip_level_count: 1,
                sample_count: 1,
                usage: TextureUsages::COPY_DST
                    | TextureUsages::COPY_SRC
                    | TextureUsages::RENDER_ATTACHMENT,
                view_formats: &[],
            },
            ..default()
        };
        export_texture.resize(size);

        images.add(export_texture)
    };
    commands
        .spawn((
            Transform::from_translation(Vec3::new(0.0, 1.5, 5.0)),
            PanOrbitCamera::default(),
        ))
        .with_child((
            Transform::from_translation(Vec3::new(1.0, 0.0, 0.0)),
            Camera3d::default(),
            Camera {
                target: RenderTarget::Image(output_texture_handle0.clone().into()),
                ..default()
            },
        ))
        .with_child((
            Transform::from_translation(Vec3::new(2.0, 0.0, 0.0)),
            Camera3d::default(),
            Camera {
                target: RenderTarget::Image(output_texture_handle1.clone().into()),
                ..default()
            },
        ));
    // commands.spawn(ImageExport(export_sources.add(output_texture_handle)));
    // Spawn the ImageExport component to initiate the export of the output texture.
    commands.spawn((
        ImageExport(export_sources.add(output_texture_handle0)),
        ImageExportSettings {
            // Frames will be saved to "./out/[#####].png".
            output_dir: "out0".into(),
            // Choose "exr" for HDR renders.
            extension: "jpeg".into(),
            enabled: true,
            ..default()
        },
    ));
    commands.spawn((
        ImageExport(export_sources.add(output_texture_handle1)),
        ImageExportSettings {
            // Frames will be saved to "./out/[#####].png".
            output_dir: "out1".into(),
            // Choose "exr" for HDR renders.
            extension: "png".into(),
            enabled: true,
            ..default()
        },
    ));
}

#[derive(Component)]
struct Rotates;

/// Rotates any entity around the x and y axis
fn rotate(time: Res<Time>, mut query: Query<&mut Transform, With<Rotates>>) {
    for mut transform in &mut query {
        transform.rotate_x(0.55 * time.delta_secs());
        transform.rotate_z(0.15 * time.delta_secs());
    }
}

fn screen_shot(mut query: Query<&mut ImageExportSettings>, keyboard: Res<ButtonInput<KeyCode>>) {
    for mut setting in &mut query {
        setting.enabled = false;
    }
    if keyboard.just_pressed(KeyCode::Space) {
        println!("screenshot!");
        for mut setting in &mut query {
            setting.enabled = true;
        }
    }
}
